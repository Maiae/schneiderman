#!/usr/bin/env python
import random

#return median of a list
#credit to http://stackoverflow.com/questions/24101524/finding-median-of-list-in-python
#pretty basic concept though
def median(lst):
    sortedLst = sorted(lst)
    lstLen = len(lst)
    index = (lstLen - 1) // 2
    if (lstLen % 2):
        return sortedLst[index]
    else:
        return (sortedLst[index] + sortedLst[index + 1])/2.0

#generates a pretty good lineup
#which is a dictinoary with key position type and key player class (which is what the database returns)
def get_lineup():
    #website specific stats
    min_salary = 3000

    #dictionary mapping numbers to positions
    position_order = {1:'PG', 2:'SG', 3:'SF', 4:'PF', 5: 'C', 6:'G', 7:'F', 8:'UTIL'}
    
    #make cumulative distribution of each position
    cum_distributions = {}
    distributions = {}
    for i in range(1, 9):
        weighted_choices = []
        for p in DATABASE.PLAYER.GET(FOREIGNKEY = position_order[i]):
            weighted_choices.append([p, 1.0*p.e_v/p.salary])
        choices, weights = zip(*weighted_choices)
        cumdist = list(itertools.accumulate(weights))
        x = random.random() * cumdist[-1]
        distributions[i] = x
        cum_distributions[i] = cumdist
        #to get one, use choices[bisect.bisect(cumdist, x)]
            
    #roster we are constructing, with stats
    roster = {}

    #randomize order we pick positions in
    x = range(1,9)
    shuffled = random.shuffle(x)
    salary = 50000
    players_left = 7
    for i in shuffled:
        #get a player p of position position_order[i] whose salary is small enough and isn't on our roster
        chosen = choices[bisect.bisect(cum_distributions[i], distributions[i])]
        while (chosen.salary > salary - min_salary*players_left or chosen.name in roster.values()):
            #pick a new one
            chosen = choices[bisect.bisect(cum_distributions[i], distributions[i])]
        #subtract his salary from salary
        salary -= chosen.salary
        roster[position_order[i]] = p.name
        players_left -= 1

    return roster


#runs the lineup generator
def main():
    #TODO: figure out how long something has been on the list
    #aka make lineups a list of tuple (roster, times)
    #TODO: finish read csv thing

    #read csv
    #a = open(exp_val, 'r')
    players = []

    #dictionary mapping numbers to positions
    position_order = {1:'PG', 2:'SG', 3:'SF', 4:'PF', 5: 'C', 6:'G', 7:'F', 8:'UTIL'}

    #generate a bunch of lineups
    #get the threshold for the top x%
    threshold = 100
    num_lineups = 1000
    num_shakes = 50
    lineups = []
    #make a box of lineups
    for i in range(0,num_lineups):
        e_v = 0
        while (e_v < threshold):
            roster = get_lineup()
            for p in roster:
                e_v += p.e_v
        lineups.append(roster)
        
    #shake the box num_shakes times
    for i in range(0,num_shakes):
        #simulate player shit
        scores = {}
        for p in players:
            scores[p.name] = numpy.random.normal(p.e_v, p.var)
        lineup_scores = []
        for lineup in lineups:
            #evaluate lineups
            for i in range(1, 9):
                cur_score += scores[lineup[position_order[i]]]
            lineup_scores.append(cur_score)
        
        median = median(lineup_scores) #get median
        lower = set()
        for i in range(0, num_lineups):
            if (lineup_scores[i] < median):
                lower.add(i) #get a set of indices below

        #coinflip to cull the below median lineups, then refill
        added = 0
        new_lineups = []
        for i in range(0, num_lineups):#go through all lineups
            if i in lower: #maybe cull
                if random.choice([True, False]): #flip coin
                    added += 1
                    new_lineups.append(lineups[i])
            else: #don't cull
                added +=1
                new_lineups.append(lineups[i]))
        for i in range(added, num_lineups): #refill
            new_lineups.append(get_lineup())
        lineups = new_lineups
    print lineups

if __name__ == "__main__":
    main()
